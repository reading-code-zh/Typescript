=== tests/cases/conformance/types/mapped/mappedTypes4.ts ===
type Box<T> = {
>Box : Box<T>

};

type Boxified<T> = {
>Boxified : Boxified<T>

    [P in keyof T]: Box<T[P]>;
};

function boxify<T>(obj: T): Boxified<T> {
>boxify : <T>(obj: T) => Boxified<T>
>obj : T

    if (typeof obj === "object") {
>typeof obj === "object" : boolean
>typeof obj : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>obj : T
>"object" : "object"

        let result = {} as Boxified<T>;
>result : Boxified<T>
>{} as Boxified<T> : Boxified<T>
>{} : {}

        for (let k in obj) {
>k : Extract<keyof T, string>
>obj : (T & object) | (T & null)

            result[k] = { value: obj[k] };
>result[k] = { value: obj[k] } : { value: (T & object)[Extract<keyof T, string>]; }
>result[k] : Boxified<T>[Extract<keyof T, string>]
>result : Boxified<T>
>k : Extract<keyof T, string>
>{ value: obj[k] } : { value: (T & object)[Extract<keyof T, string>]; }
>value : (T & object)[Extract<keyof T, string>]
>obj[k] : (T & object)[Extract<keyof T, string>]
>obj : T & object
>k : Extract<keyof T, string>
        }
        return result;
>result : Boxified<T>
    }
    return <any>obj;
><any>obj : any
>obj : T
}

type A = { a: string };
>A : { a: string; }
>a : string

type B = { b: string };
>B : { b: string; }
>b : string

type C = { c: string };
>C : { c: string; }
>c : string

function f1(x: A | B | C | undefined) {
>f1 : (x: A | B | C | undefined) => Boxified<A | B | C | undefined>
>x : A | B | C | undefined

    return boxify(x);
>boxify(x) : Boxified<A | B | C | undefined>
>boxify : <T>(obj: T) => Boxified<T>
>x : A | B | C | undefined
}

type T00 = Partial<A | B | C>;
>T00 : Partial<A> | Partial<B> | Partial<C>

type T01 = Readonly<A | B | C | null | undefined>;
>T01 : Readonly<A> | Readonly<B> | Readonly<C> | null | undefined
>null : null

type T02 = Boxified<A | B[] | C | string>
>T02 : string | Boxified<A> | Boxified<C> | Box<B>[]

type T03 = Readonly<string | number | boolean | null | undefined | void>;
>T03 : string | number | boolean | void | null | undefined
>null : null

type T04 = Boxified<string | number | boolean | null | undefined | void>;
>T04 : string | number | boolean | void | null | undefined
>null : null

type T05 = Partial<"hello" | "world" | 42>;
>T05 : "hello" | "world" | 42

type BoxifiedWithSentinel<T, U> = {
>BoxifiedWithSentinel : BoxifiedWithSentinel<T, U>

    [P in keyof T]: Box<T[P]> | U;
}

type T10 = BoxifiedWithSentinel<A | B | C, null>;
>T10 : BoxifiedWithSentinel<A, null> | BoxifiedWithSentinel<B, null> | BoxifiedWithSentinel<C, null>
>null : null

type T11 = BoxifiedWithSentinel<A | B | C, undefined>;
>T11 : BoxifiedWithSentinel<A, undefined> | BoxifiedWithSentinel<B, undefined> | BoxifiedWithSentinel<C, undefined>

type T12 = BoxifiedWithSentinel<string, undefined>;
>T12 : string

type DeepReadonly<T> = {
>DeepReadonly : DeepReadonly<T>

    readonly [P in keyof T]: DeepReadonly<T[P]>;
};

type Foo = {
>Foo : { x: number; y: {    a: string;    b: number;}; z: boolean; }

    x: number;
>x : number

    y: { a: string, b: number };
>y : { a: string; b: number; }
>a : string
>b : number

    z: boolean;
>z : boolean

};

type DeepReadonlyFoo = {
>DeepReadonlyFoo : { readonly x: number; readonly y: {    readonly a: string;    readonly b: number;}; readonly z: boolean; }

    readonly x: number;
>x : number

    readonly y: { readonly a: string, readonly b: number };
>y : { readonly a: string; readonly b: number; }
>a : string
>b : number

    readonly z: boolean;
>z : boolean

};

var x1: DeepReadonly<Foo>;
>x1 : DeepReadonly<Foo>

var x1: DeepReadonlyFoo;
>x1 : DeepReadonly<Foo>

// Repro from #13232

type Z = { a: number };
>Z : { a: number; }
>a : number

type Clone<T> = {
>Clone : Clone<T>

  [P in keyof (T & {})]: (T & {})[P];
};
type M = Clone<Z>; // M should be { a: number }
>M : { a: number; }

var z1: Z;
>z1 : Z

var z1: Clone<Z>;
>z1 : Z

