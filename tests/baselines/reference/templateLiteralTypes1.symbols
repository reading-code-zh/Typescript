=== tests/cases/conformance/types/literal/templateLiteralTypes1.ts ===
// Template types example from #12754

const createScopedActionType = <S extends string>(scope: S) => <T extends string>(type: T) => `${scope}/${type}` as `${S}/${T}`;
>createScopedActionType : Symbol(createScopedActionType, Decl(templateLiteralTypes1.ts, 2, 5))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 2, 32))
>scope : Symbol(scope, Decl(templateLiteralTypes1.ts, 2, 50))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 2, 32))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 2, 64))
>type : Symbol(type, Decl(templateLiteralTypes1.ts, 2, 82))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 2, 64))
>scope : Symbol(scope, Decl(templateLiteralTypes1.ts, 2, 50))
>type : Symbol(type, Decl(templateLiteralTypes1.ts, 2, 82))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 2, 32))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 2, 64))

const createActionInMyScope = createScopedActionType("MyScope");  // <T extends string>(type: T) => `MyScope/${T}`
>createActionInMyScope : Symbol(createActionInMyScope, Decl(templateLiteralTypes1.ts, 3, 5))
>createScopedActionType : Symbol(createScopedActionType, Decl(templateLiteralTypes1.ts, 2, 5))

const MY_ACTION = createActionInMyScope("MY_ACTION");  // 'MyScope/MY_ACTION'
>MY_ACTION : Symbol(MY_ACTION, Decl(templateLiteralTypes1.ts, 4, 5))
>createActionInMyScope : Symbol(createActionInMyScope, Decl(templateLiteralTypes1.ts, 3, 5))

// Union types are distributed over template types

type EventName<S extends string> = `${S}Changed`;
>EventName : Symbol(EventName, Decl(templateLiteralTypes1.ts, 4, 53))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 8, 15))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 8, 15))

type EN1 = EventName<'Foo' | 'Bar' | 'Baz'>;
>EN1 : Symbol(EN1, Decl(templateLiteralTypes1.ts, 8, 49))
>EventName : Symbol(EventName, Decl(templateLiteralTypes1.ts, 4, 53))

type Loc = `${'top' | 'middle' | 'bottom'}-${'left' | 'center' | 'right'}`;
>Loc : Symbol(Loc, Decl(templateLiteralTypes1.ts, 9, 44))

// Primitive literal types can be spread into templates

type ToString<T extends string | number | boolean | bigint> = `${T}`;
>ToString : Symbol(ToString, Decl(templateLiteralTypes1.ts, 10, 75))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 14, 14))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 14, 14))

type TS1 = ToString<'abc' | 42 | true | -1234n>;
>TS1 : Symbol(TS1, Decl(templateLiteralTypes1.ts, 14, 69))
>ToString : Symbol(ToString, Decl(templateLiteralTypes1.ts, 10, 75))

// Nested template literal type normalization

type TL1<T extends string> = `a${T}b${T}c`;
>TL1 : Symbol(TL1, Decl(templateLiteralTypes1.ts, 15, 48))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 19, 9))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 19, 9))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 19, 9))

type TL2<U extends string> = TL1<`x${U}y`>;  // `ax${U}ybx{$U}yc`
>TL2 : Symbol(TL2, Decl(templateLiteralTypes1.ts, 19, 43))
>U : Symbol(U, Decl(templateLiteralTypes1.ts, 20, 9))
>TL1 : Symbol(TL1, Decl(templateLiteralTypes1.ts, 15, 48))
>U : Symbol(U, Decl(templateLiteralTypes1.ts, 20, 9))

type TL3 = TL2<'o'>;  // 'axoybxoyc'
>TL3 : Symbol(TL3, Decl(templateLiteralTypes1.ts, 20, 43))
>TL2 : Symbol(TL2, Decl(templateLiteralTypes1.ts, 19, 43))

// Casing intrinsics

type Cases<T extends string> = `${Uppercase<T>} ${Lowercase<T>} ${Capitalize<T>} ${Uncapitalize<T>}`;
>Cases : Symbol(Cases, Decl(templateLiteralTypes1.ts, 21, 20))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 25, 11))
>Uppercase : Symbol(Uppercase, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 25, 11))
>Lowercase : Symbol(Lowercase, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 25, 11))
>Capitalize : Symbol(Capitalize, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 25, 11))
>Uncapitalize : Symbol(Uncapitalize, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 25, 11))

type TCA1 = Cases<'bar'>;  // 'BAR bar Bar bar'
>TCA1 : Symbol(TCA1, Decl(templateLiteralTypes1.ts, 25, 101))
>Cases : Symbol(Cases, Decl(templateLiteralTypes1.ts, 21, 20))

type TCA2 = Cases<'BAR'>;  // 'BAR bar BAR bAR'
>TCA2 : Symbol(TCA2, Decl(templateLiteralTypes1.ts, 27, 25))
>Cases : Symbol(Cases, Decl(templateLiteralTypes1.ts, 21, 20))

// Assignability

function test<T extends 'foo' | 'bar'>(name: `get${Capitalize<T>}`) {
>test : Symbol(test, Decl(templateLiteralTypes1.ts, 28, 25))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 32, 14))
>name : Symbol(name, Decl(templateLiteralTypes1.ts, 32, 39))
>Capitalize : Symbol(Capitalize, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 32, 14))

    let s1: string = name;
>s1 : Symbol(s1, Decl(templateLiteralTypes1.ts, 33, 7))
>name : Symbol(name, Decl(templateLiteralTypes1.ts, 32, 39))

    let s2: 'getFoo' | 'getBar' = name;
>s2 : Symbol(s2, Decl(templateLiteralTypes1.ts, 34, 7))
>name : Symbol(name, Decl(templateLiteralTypes1.ts, 32, 39))
}

function fa1<T>(x: T, y: { [P in keyof T]: T[P] }, z: { [P in keyof T & string as `p_${P}`]: T[P] }) {
>fa1 : Symbol(fa1, Decl(templateLiteralTypes1.ts, 35, 1))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 37, 13))
>x : Symbol(x, Decl(templateLiteralTypes1.ts, 37, 16))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 37, 13))
>y : Symbol(y, Decl(templateLiteralTypes1.ts, 37, 21))
>P : Symbol(P, Decl(templateLiteralTypes1.ts, 37, 28))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 37, 13))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 37, 13))
>P : Symbol(P, Decl(templateLiteralTypes1.ts, 37, 28))
>z : Symbol(z, Decl(templateLiteralTypes1.ts, 37, 50))
>P : Symbol(P, Decl(templateLiteralTypes1.ts, 37, 57))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 37, 13))
>P : Symbol(P, Decl(templateLiteralTypes1.ts, 37, 57))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 37, 13))
>P : Symbol(P, Decl(templateLiteralTypes1.ts, 37, 57))

    y = x;
>y : Symbol(y, Decl(templateLiteralTypes1.ts, 37, 21))
>x : Symbol(x, Decl(templateLiteralTypes1.ts, 37, 16))

    z = x;  // Error
>z : Symbol(z, Decl(templateLiteralTypes1.ts, 37, 50))
>x : Symbol(x, Decl(templateLiteralTypes1.ts, 37, 16))
}

function fa2<T, U extends T, A extends string, B extends A>(x: { [P in B as `p_${P}`]: T }, y: { [Q in A as `p_${Q}`]: U }) {
>fa2 : Symbol(fa2, Decl(templateLiteralTypes1.ts, 40, 1))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 42, 13))
>U : Symbol(U, Decl(templateLiteralTypes1.ts, 42, 15))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 42, 13))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 42, 28))
>B : Symbol(B, Decl(templateLiteralTypes1.ts, 42, 46))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 42, 28))
>x : Symbol(x, Decl(templateLiteralTypes1.ts, 42, 60))
>P : Symbol(P, Decl(templateLiteralTypes1.ts, 42, 66))
>B : Symbol(B, Decl(templateLiteralTypes1.ts, 42, 46))
>P : Symbol(P, Decl(templateLiteralTypes1.ts, 42, 66))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 42, 13))
>y : Symbol(y, Decl(templateLiteralTypes1.ts, 42, 91))
>Q : Symbol(Q, Decl(templateLiteralTypes1.ts, 42, 98))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 42, 28))
>Q : Symbol(Q, Decl(templateLiteralTypes1.ts, 42, 98))
>U : Symbol(U, Decl(templateLiteralTypes1.ts, 42, 15))

    x = y;
>x : Symbol(x, Decl(templateLiteralTypes1.ts, 42, 60))
>y : Symbol(y, Decl(templateLiteralTypes1.ts, 42, 91))

    y = x;  // Error
>y : Symbol(y, Decl(templateLiteralTypes1.ts, 42, 91))
>x : Symbol(x, Decl(templateLiteralTypes1.ts, 42, 60))
}

// String transformations using recursive conditional types

type Join<T extends unknown[], D extends string> =
>Join : Symbol(Join, Decl(templateLiteralTypes1.ts, 45, 1))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 49, 10))
>D : Symbol(D, Decl(templateLiteralTypes1.ts, 49, 30))

    T extends [] ? '' :
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 49, 10))

    T extends [string | number | boolean | bigint] ? `${T[0]}` :
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 49, 10))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 49, 10))

    T extends [string | number | boolean | bigint, ...infer U] ? `${T[0]}${D}${Join<U, D>}` :
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 49, 10))
>U : Symbol(U, Decl(templateLiteralTypes1.ts, 52, 59))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 49, 10))
>D : Symbol(D, Decl(templateLiteralTypes1.ts, 49, 30))
>Join : Symbol(Join, Decl(templateLiteralTypes1.ts, 45, 1))
>U : Symbol(U, Decl(templateLiteralTypes1.ts, 52, 59))
>D : Symbol(D, Decl(templateLiteralTypes1.ts, 49, 30))

    string;

type TJ1 = Join<[1, 2, 3, 4], '.'>
>TJ1 : Symbol(TJ1, Decl(templateLiteralTypes1.ts, 53, 11))
>Join : Symbol(Join, Decl(templateLiteralTypes1.ts, 45, 1))

type TJ2 = Join<['foo', 'bar', 'baz'], '-'>;
>TJ2 : Symbol(TJ2, Decl(templateLiteralTypes1.ts, 55, 34))
>Join : Symbol(Join, Decl(templateLiteralTypes1.ts, 45, 1))

type TJ3 = Join<[], '.'>
>TJ3 : Symbol(TJ3, Decl(templateLiteralTypes1.ts, 56, 44))
>Join : Symbol(Join, Decl(templateLiteralTypes1.ts, 45, 1))

// Inference based on delimiters

type MatchPair<S extends string> = S extends `[${infer A},${infer B}]` ? [A, B] : unknown;
>MatchPair : Symbol(MatchPair, Decl(templateLiteralTypes1.ts, 57, 24))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 61, 15))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 61, 15))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 61, 54))
>B : Symbol(B, Decl(templateLiteralTypes1.ts, 61, 65))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 61, 54))
>B : Symbol(B, Decl(templateLiteralTypes1.ts, 61, 65))

type T20 = MatchPair<'[1,2]'>;  // ['1', '2']
>T20 : Symbol(T20, Decl(templateLiteralTypes1.ts, 61, 90))
>MatchPair : Symbol(MatchPair, Decl(templateLiteralTypes1.ts, 57, 24))

type T21 = MatchPair<'[foo,bar]'>;  // ['foo', 'bar']
>T21 : Symbol(T21, Decl(templateLiteralTypes1.ts, 63, 30))
>MatchPair : Symbol(MatchPair, Decl(templateLiteralTypes1.ts, 57, 24))

type T22 = MatchPair<' [1,2]'>;  // unknown
>T22 : Symbol(T22, Decl(templateLiteralTypes1.ts, 64, 34))
>MatchPair : Symbol(MatchPair, Decl(templateLiteralTypes1.ts, 57, 24))

type T23 = MatchPair<'[123]'>;  // unknown
>T23 : Symbol(T23, Decl(templateLiteralTypes1.ts, 65, 31))
>MatchPair : Symbol(MatchPair, Decl(templateLiteralTypes1.ts, 57, 24))

type T24 = MatchPair<'[1,2,3,4]'>;  // ['1', '2,3,4']
>T24 : Symbol(T24, Decl(templateLiteralTypes1.ts, 66, 30))
>MatchPair : Symbol(MatchPair, Decl(templateLiteralTypes1.ts, 57, 24))

type SnakeToCamelCase<S extends string> =
>SnakeToCamelCase : Symbol(SnakeToCamelCase, Decl(templateLiteralTypes1.ts, 67, 34))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 69, 22))

    S extends `${infer T}_${infer U}` ? `${Lowercase<T>}${SnakeToPascalCase<U>}` :
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 69, 22))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 70, 22))
>U : Symbol(U, Decl(templateLiteralTypes1.ts, 70, 33))
>Lowercase : Symbol(Lowercase, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 70, 22))
>SnakeToPascalCase : Symbol(SnakeToPascalCase, Decl(templateLiteralTypes1.ts, 72, 25))
>U : Symbol(U, Decl(templateLiteralTypes1.ts, 70, 33))

    S extends `${infer T}` ? `${Lowercase<T>}` :
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 69, 22))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 71, 22))
>Lowercase : Symbol(Lowercase, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 71, 22))

    SnakeToPascalCase<S>;
>SnakeToPascalCase : Symbol(SnakeToPascalCase, Decl(templateLiteralTypes1.ts, 72, 25))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 69, 22))

type SnakeToPascalCase<S extends string> =
>SnakeToPascalCase : Symbol(SnakeToPascalCase, Decl(templateLiteralTypes1.ts, 72, 25))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 74, 23))

    string extends S ? string :
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 74, 23))

    S extends `${infer T}_${infer U}` ? `${Capitalize<Lowercase<T>>}${SnakeToPascalCase<U>}` :
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 74, 23))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 76, 22))
>U : Symbol(U, Decl(templateLiteralTypes1.ts, 76, 33))
>Capitalize : Symbol(Capitalize, Decl(lib.es5.d.ts, --, --))
>Lowercase : Symbol(Lowercase, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 76, 22))
>SnakeToPascalCase : Symbol(SnakeToPascalCase, Decl(templateLiteralTypes1.ts, 72, 25))
>U : Symbol(U, Decl(templateLiteralTypes1.ts, 76, 33))

    S extends `${infer T}` ? `${Capitalize<Lowercase<T>>}` :
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 74, 23))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 77, 22))
>Capitalize : Symbol(Capitalize, Decl(lib.es5.d.ts, --, --))
>Lowercase : Symbol(Lowercase, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 77, 22))

    never;

type RR0 = SnakeToPascalCase<'hello_world_foo'>;  // 'HelloWorldFoo'
>RR0 : Symbol(RR0, Decl(templateLiteralTypes1.ts, 78, 10))
>SnakeToPascalCase : Symbol(SnakeToPascalCase, Decl(templateLiteralTypes1.ts, 72, 25))

type RR1 = SnakeToPascalCase<'FOO_BAR_BAZ'>;  // 'FooBarBaz'
>RR1 : Symbol(RR1, Decl(templateLiteralTypes1.ts, 80, 48))
>SnakeToPascalCase : Symbol(SnakeToPascalCase, Decl(templateLiteralTypes1.ts, 72, 25))

type RR2 = SnakeToCamelCase<'hello_world_foo'>;  // 'helloWorldFoo'
>RR2 : Symbol(RR2, Decl(templateLiteralTypes1.ts, 81, 44))
>SnakeToCamelCase : Symbol(SnakeToCamelCase, Decl(templateLiteralTypes1.ts, 67, 34))

type RR3 = SnakeToCamelCase<'FOO_BAR_BAZ'>;  // 'fooBarBaz'
>RR3 : Symbol(RR3, Decl(templateLiteralTypes1.ts, 82, 47))
>SnakeToCamelCase : Symbol(SnakeToCamelCase, Decl(templateLiteralTypes1.ts, 67, 34))

// Single character inference

type FirstTwoAndRest<S extends string> = S extends `${infer A}${infer B}${infer R}` ? [`${A}${B}`, R] : unknown;
>FirstTwoAndRest : Symbol(FirstTwoAndRest, Decl(templateLiteralTypes1.ts, 83, 43))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 87, 21))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 87, 21))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 87, 59))
>B : Symbol(B, Decl(templateLiteralTypes1.ts, 87, 69))
>R : Symbol(R, Decl(templateLiteralTypes1.ts, 87, 79))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 87, 59))
>B : Symbol(B, Decl(templateLiteralTypes1.ts, 87, 69))
>R : Symbol(R, Decl(templateLiteralTypes1.ts, 87, 79))

type T25 = FirstTwoAndRest<'abcde'>;  // ['ab', 'cde']
>T25 : Symbol(T25, Decl(templateLiteralTypes1.ts, 87, 112))
>FirstTwoAndRest : Symbol(FirstTwoAndRest, Decl(templateLiteralTypes1.ts, 83, 43))

type T26 = FirstTwoAndRest<'ab'>;  // ['ab', '']
>T26 : Symbol(T26, Decl(templateLiteralTypes1.ts, 89, 36))
>FirstTwoAndRest : Symbol(FirstTwoAndRest, Decl(templateLiteralTypes1.ts, 83, 43))

type T27 = FirstTwoAndRest<'a'>;  // unknown
>T27 : Symbol(T27, Decl(templateLiteralTypes1.ts, 90, 33))
>FirstTwoAndRest : Symbol(FirstTwoAndRest, Decl(templateLiteralTypes1.ts, 83, 43))

type HexDigit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' |'8' | '9' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f';
>HexDigit : Symbol(HexDigit, Decl(templateLiteralTypes1.ts, 91, 32))

type HexColor<S extends string> =
>HexColor : Symbol(HexColor, Decl(templateLiteralTypes1.ts, 93, 145))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 95, 14))

    S extends `#${infer R1}${infer R2}${infer G1}${infer G2}${infer B1}${infer B2}` ?
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 95, 14))
>R1 : Symbol(R1, Decl(templateLiteralTypes1.ts, 96, 23))
>R2 : Symbol(R2, Decl(templateLiteralTypes1.ts, 96, 34))
>G1 : Symbol(G1, Decl(templateLiteralTypes1.ts, 96, 45))
>G2 : Symbol(G2, Decl(templateLiteralTypes1.ts, 96, 56))
>B1 : Symbol(B1, Decl(templateLiteralTypes1.ts, 96, 67))
>B2 : Symbol(B2, Decl(templateLiteralTypes1.ts, 96, 78))

        [R1, R2, G1, G2, B1, B2] extends [HexDigit, HexDigit, HexDigit, HexDigit, HexDigit, HexDigit] ?
>R1 : Symbol(R1, Decl(templateLiteralTypes1.ts, 96, 23))
>R2 : Symbol(R2, Decl(templateLiteralTypes1.ts, 96, 34))
>G1 : Symbol(G1, Decl(templateLiteralTypes1.ts, 96, 45))
>G2 : Symbol(G2, Decl(templateLiteralTypes1.ts, 96, 56))
>B1 : Symbol(B1, Decl(templateLiteralTypes1.ts, 96, 67))
>B2 : Symbol(B2, Decl(templateLiteralTypes1.ts, 96, 78))
>HexDigit : Symbol(HexDigit, Decl(templateLiteralTypes1.ts, 91, 32))
>HexDigit : Symbol(HexDigit, Decl(templateLiteralTypes1.ts, 91, 32))
>HexDigit : Symbol(HexDigit, Decl(templateLiteralTypes1.ts, 91, 32))
>HexDigit : Symbol(HexDigit, Decl(templateLiteralTypes1.ts, 91, 32))
>HexDigit : Symbol(HexDigit, Decl(templateLiteralTypes1.ts, 91, 32))
>HexDigit : Symbol(HexDigit, Decl(templateLiteralTypes1.ts, 91, 32))

            S :
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 95, 14))

            never :
        never;

type TH1 = HexColor<'#8080FF'>;  // '#8080FF'
>TH1 : Symbol(TH1, Decl(templateLiteralTypes1.ts, 100, 14))
>HexColor : Symbol(HexColor, Decl(templateLiteralTypes1.ts, 93, 145))

type TH2 = HexColor<'#80c0ff'>;  // '#80c0ff'
>TH2 : Symbol(TH2, Decl(templateLiteralTypes1.ts, 102, 31))
>HexColor : Symbol(HexColor, Decl(templateLiteralTypes1.ts, 93, 145))

type TH3 = HexColor<'#8080F'>;  // never
>TH3 : Symbol(TH3, Decl(templateLiteralTypes1.ts, 103, 31))
>HexColor : Symbol(HexColor, Decl(templateLiteralTypes1.ts, 93, 145))

type TH4 = HexColor<'#8080FFF'>;  // never
>TH4 : Symbol(TH4, Decl(templateLiteralTypes1.ts, 104, 30))
>HexColor : Symbol(HexColor, Decl(templateLiteralTypes1.ts, 93, 145))

// Recursive inference

type Trim<S extends string> =
>Trim : Symbol(Trim, Decl(templateLiteralTypes1.ts, 105, 32))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 109, 10))

    S extends ` ${infer T}` ? Trim<T> :
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 109, 10))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 110, 23))
>Trim : Symbol(Trim, Decl(templateLiteralTypes1.ts, 105, 32))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 110, 23))

    S extends `${infer T} ` ? Trim<T> :
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 109, 10))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 111, 22))
>Trim : Symbol(Trim, Decl(templateLiteralTypes1.ts, 105, 32))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 111, 22))

    S;
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 109, 10))

type TR1 = Trim<'xx   '>;  // 'xx'
>TR1 : Symbol(TR1, Decl(templateLiteralTypes1.ts, 112, 6))
>Trim : Symbol(Trim, Decl(templateLiteralTypes1.ts, 105, 32))

type TR2 = Trim<'   xx'>;  // 'xx'
>TR2 : Symbol(TR2, Decl(templateLiteralTypes1.ts, 114, 25))
>Trim : Symbol(Trim, Decl(templateLiteralTypes1.ts, 105, 32))

type TR3 = Trim<'   xx   '>;  // 'xx'
>TR3 : Symbol(TR3, Decl(templateLiteralTypes1.ts, 115, 25))
>Trim : Symbol(Trim, Decl(templateLiteralTypes1.ts, 105, 32))

type Split<S extends string, D extends string> =
>Split : Symbol(Split, Decl(templateLiteralTypes1.ts, 116, 28))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 118, 11))
>D : Symbol(D, Decl(templateLiteralTypes1.ts, 118, 28))

    string extends S ? string[] :
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 118, 11))

    S extends '' ? [] :
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 118, 11))

    S extends `${infer T}${D}${infer U}` ? [T, ...Split<U, D>] :
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 118, 11))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 121, 22))
>D : Symbol(D, Decl(templateLiteralTypes1.ts, 118, 28))
>U : Symbol(U, Decl(templateLiteralTypes1.ts, 121, 36))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 121, 22))
>Split : Symbol(Split, Decl(templateLiteralTypes1.ts, 116, 28))
>U : Symbol(U, Decl(templateLiteralTypes1.ts, 121, 36))
>D : Symbol(D, Decl(templateLiteralTypes1.ts, 118, 28))

    [S];
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 118, 11))

type T40 = Split<'foo', '.'>;  // ['foo']
>T40 : Symbol(T40, Decl(templateLiteralTypes1.ts, 122, 8))
>Split : Symbol(Split, Decl(templateLiteralTypes1.ts, 116, 28))

type T41 = Split<'foo.bar.baz', '.'>;  // ['foo', 'bar', 'baz']
>T41 : Symbol(T41, Decl(templateLiteralTypes1.ts, 124, 29))
>Split : Symbol(Split, Decl(templateLiteralTypes1.ts, 116, 28))

type T42 = Split<'foo.bar', ''>;  // ['f', 'o', 'o', '.', 'b', 'a', 'r']
>T42 : Symbol(T42, Decl(templateLiteralTypes1.ts, 125, 37))
>Split : Symbol(Split, Decl(templateLiteralTypes1.ts, 116, 28))

type T43 = Split<any, '.'>;  // string[]
>T43 : Symbol(T43, Decl(templateLiteralTypes1.ts, 126, 32))
>Split : Symbol(Split, Decl(templateLiteralTypes1.ts, 116, 28))

// Inference and property name paths

declare function getProp<T, P0 extends keyof T & string, P1 extends keyof T[P0] & string, P2 extends keyof T[P0][P1] & string>(obj: T, path: `${P0}.${P1}.${P2}`): T[P0][P1][P2];
>getProp : Symbol(getProp, Decl(templateLiteralTypes1.ts, 127, 27), Decl(templateLiteralTypes1.ts, 131, 177), Decl(templateLiteralTypes1.ts, 132, 130), Decl(templateLiteralTypes1.ts, 133, 82))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 131, 25))
>P0 : Symbol(P0, Decl(templateLiteralTypes1.ts, 131, 27))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 131, 25))
>P1 : Symbol(P1, Decl(templateLiteralTypes1.ts, 131, 56))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 131, 25))
>P0 : Symbol(P0, Decl(templateLiteralTypes1.ts, 131, 27))
>P2 : Symbol(P2, Decl(templateLiteralTypes1.ts, 131, 89))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 131, 25))
>P0 : Symbol(P0, Decl(templateLiteralTypes1.ts, 131, 27))
>P1 : Symbol(P1, Decl(templateLiteralTypes1.ts, 131, 56))
>obj : Symbol(obj, Decl(templateLiteralTypes1.ts, 131, 127))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 131, 25))
>path : Symbol(path, Decl(templateLiteralTypes1.ts, 131, 134))
>P0 : Symbol(P0, Decl(templateLiteralTypes1.ts, 131, 27))
>P1 : Symbol(P1, Decl(templateLiteralTypes1.ts, 131, 56))
>P2 : Symbol(P2, Decl(templateLiteralTypes1.ts, 131, 89))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 131, 25))
>P0 : Symbol(P0, Decl(templateLiteralTypes1.ts, 131, 27))
>P1 : Symbol(P1, Decl(templateLiteralTypes1.ts, 131, 56))
>P2 : Symbol(P2, Decl(templateLiteralTypes1.ts, 131, 89))

declare function getProp<T, P0 extends keyof T & string, P1 extends keyof T[P0] & string>(obj: T, path: `${P0}.${P1}`): T[P0][P1];
>getProp : Symbol(getProp, Decl(templateLiteralTypes1.ts, 127, 27), Decl(templateLiteralTypes1.ts, 131, 177), Decl(templateLiteralTypes1.ts, 132, 130), Decl(templateLiteralTypes1.ts, 133, 82))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 132, 25))
>P0 : Symbol(P0, Decl(templateLiteralTypes1.ts, 132, 27))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 132, 25))
>P1 : Symbol(P1, Decl(templateLiteralTypes1.ts, 132, 56))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 132, 25))
>P0 : Symbol(P0, Decl(templateLiteralTypes1.ts, 132, 27))
>obj : Symbol(obj, Decl(templateLiteralTypes1.ts, 132, 90))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 132, 25))
>path : Symbol(path, Decl(templateLiteralTypes1.ts, 132, 97))
>P0 : Symbol(P0, Decl(templateLiteralTypes1.ts, 132, 27))
>P1 : Symbol(P1, Decl(templateLiteralTypes1.ts, 132, 56))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 132, 25))
>P0 : Symbol(P0, Decl(templateLiteralTypes1.ts, 132, 27))
>P1 : Symbol(P1, Decl(templateLiteralTypes1.ts, 132, 56))

declare function getProp<T, P0 extends keyof T & string>(obj: T, path: P0): T[P0];
>getProp : Symbol(getProp, Decl(templateLiteralTypes1.ts, 127, 27), Decl(templateLiteralTypes1.ts, 131, 177), Decl(templateLiteralTypes1.ts, 132, 130), Decl(templateLiteralTypes1.ts, 133, 82))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 133, 25))
>P0 : Symbol(P0, Decl(templateLiteralTypes1.ts, 133, 27))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 133, 25))
>obj : Symbol(obj, Decl(templateLiteralTypes1.ts, 133, 57))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 133, 25))
>path : Symbol(path, Decl(templateLiteralTypes1.ts, 133, 64))
>P0 : Symbol(P0, Decl(templateLiteralTypes1.ts, 133, 27))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 133, 25))
>P0 : Symbol(P0, Decl(templateLiteralTypes1.ts, 133, 27))

declare function getProp(obj: object, path: string): unknown;
>getProp : Symbol(getProp, Decl(templateLiteralTypes1.ts, 127, 27), Decl(templateLiteralTypes1.ts, 131, 177), Decl(templateLiteralTypes1.ts, 132, 130), Decl(templateLiteralTypes1.ts, 133, 82))
>obj : Symbol(obj, Decl(templateLiteralTypes1.ts, 134, 25))
>path : Symbol(path, Decl(templateLiteralTypes1.ts, 134, 37))

let p1 = getProp({ a: { b: {c: 42, d: 'hello' }}} as const, 'a');
>p1 : Symbol(p1, Decl(templateLiteralTypes1.ts, 136, 3))
>getProp : Symbol(getProp, Decl(templateLiteralTypes1.ts, 127, 27), Decl(templateLiteralTypes1.ts, 131, 177), Decl(templateLiteralTypes1.ts, 132, 130), Decl(templateLiteralTypes1.ts, 133, 82))
>a : Symbol(a, Decl(templateLiteralTypes1.ts, 136, 18))
>b : Symbol(b, Decl(templateLiteralTypes1.ts, 136, 23))
>c : Symbol(c, Decl(templateLiteralTypes1.ts, 136, 28))
>d : Symbol(d, Decl(templateLiteralTypes1.ts, 136, 34))
>const : Symbol(const)

let p2 = getProp({ a: { b: {c: 42, d: 'hello' }}} as const, 'a.b');
>p2 : Symbol(p2, Decl(templateLiteralTypes1.ts, 137, 3))
>getProp : Symbol(getProp, Decl(templateLiteralTypes1.ts, 127, 27), Decl(templateLiteralTypes1.ts, 131, 177), Decl(templateLiteralTypes1.ts, 132, 130), Decl(templateLiteralTypes1.ts, 133, 82))
>a : Symbol(a, Decl(templateLiteralTypes1.ts, 137, 18))
>b : Symbol(b, Decl(templateLiteralTypes1.ts, 137, 23))
>c : Symbol(c, Decl(templateLiteralTypes1.ts, 137, 28))
>d : Symbol(d, Decl(templateLiteralTypes1.ts, 137, 34))
>const : Symbol(const)

let p3 = getProp({ a: { b: {c: 42, d: 'hello' }}} as const, 'a.b.d');
>p3 : Symbol(p3, Decl(templateLiteralTypes1.ts, 138, 3))
>getProp : Symbol(getProp, Decl(templateLiteralTypes1.ts, 127, 27), Decl(templateLiteralTypes1.ts, 131, 177), Decl(templateLiteralTypes1.ts, 132, 130), Decl(templateLiteralTypes1.ts, 133, 82))
>a : Symbol(a, Decl(templateLiteralTypes1.ts, 138, 18))
>b : Symbol(b, Decl(templateLiteralTypes1.ts, 138, 23))
>c : Symbol(c, Decl(templateLiteralTypes1.ts, 138, 28))
>d : Symbol(d, Decl(templateLiteralTypes1.ts, 138, 34))
>const : Symbol(const)

type PropType<T, Path extends string> =
>PropType : Symbol(PropType, Decl(templateLiteralTypes1.ts, 138, 69))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 140, 14))
>Path : Symbol(Path, Decl(templateLiteralTypes1.ts, 140, 16))

    string extends Path ? unknown :
>Path : Symbol(Path, Decl(templateLiteralTypes1.ts, 140, 16))

    Path extends keyof T ? T[Path] :
>Path : Symbol(Path, Decl(templateLiteralTypes1.ts, 140, 16))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 140, 14))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 140, 14))
>Path : Symbol(Path, Decl(templateLiteralTypes1.ts, 140, 16))

    Path extends `${infer K}.${infer R}` ? K extends keyof T ? PropType<T[K], R> : unknown :
>Path : Symbol(Path, Decl(templateLiteralTypes1.ts, 140, 16))
>K : Symbol(K, Decl(templateLiteralTypes1.ts, 143, 25))
>R : Symbol(R, Decl(templateLiteralTypes1.ts, 143, 36))
>K : Symbol(K, Decl(templateLiteralTypes1.ts, 143, 25))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 140, 14))
>PropType : Symbol(PropType, Decl(templateLiteralTypes1.ts, 138, 69))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 140, 14))
>K : Symbol(K, Decl(templateLiteralTypes1.ts, 143, 25))
>R : Symbol(R, Decl(templateLiteralTypes1.ts, 143, 36))

    unknown;

declare function getPropValue<T, P extends string>(obj: T, path: P): PropType<T, P>;
>getPropValue : Symbol(getPropValue, Decl(templateLiteralTypes1.ts, 144, 12))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 146, 30))
>P : Symbol(P, Decl(templateLiteralTypes1.ts, 146, 32))
>obj : Symbol(obj, Decl(templateLiteralTypes1.ts, 146, 51))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 146, 30))
>path : Symbol(path, Decl(templateLiteralTypes1.ts, 146, 58))
>P : Symbol(P, Decl(templateLiteralTypes1.ts, 146, 32))
>PropType : Symbol(PropType, Decl(templateLiteralTypes1.ts, 138, 69))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 146, 30))
>P : Symbol(P, Decl(templateLiteralTypes1.ts, 146, 32))

declare const s: string;
>s : Symbol(s, Decl(templateLiteralTypes1.ts, 147, 13))

const obj = { a: { b: {c: 42, d: 'hello' }}};
>obj : Symbol(obj, Decl(templateLiteralTypes1.ts, 149, 5))
>a : Symbol(a, Decl(templateLiteralTypes1.ts, 149, 13))
>b : Symbol(b, Decl(templateLiteralTypes1.ts, 149, 18))
>c : Symbol(c, Decl(templateLiteralTypes1.ts, 149, 23))
>d : Symbol(d, Decl(templateLiteralTypes1.ts, 149, 29))

getPropValue(obj, 'a');  // { b: {c: number, d: string } }
>getPropValue : Symbol(getPropValue, Decl(templateLiteralTypes1.ts, 144, 12))
>obj : Symbol(obj, Decl(templateLiteralTypes1.ts, 149, 5))

getPropValue(obj, 'a.b');  // {c: number, d: string }
>getPropValue : Symbol(getPropValue, Decl(templateLiteralTypes1.ts, 144, 12))
>obj : Symbol(obj, Decl(templateLiteralTypes1.ts, 149, 5))

getPropValue(obj, 'a.b.d');  // string
>getPropValue : Symbol(getPropValue, Decl(templateLiteralTypes1.ts, 144, 12))
>obj : Symbol(obj, Decl(templateLiteralTypes1.ts, 149, 5))

getPropValue(obj, 'a.b.x');  // unknown
>getPropValue : Symbol(getPropValue, Decl(templateLiteralTypes1.ts, 144, 12))
>obj : Symbol(obj, Decl(templateLiteralTypes1.ts, 149, 5))

getPropValue(obj, s);  // unknown
>getPropValue : Symbol(getPropValue, Decl(templateLiteralTypes1.ts, 144, 12))
>obj : Symbol(obj, Decl(templateLiteralTypes1.ts, 149, 5))
>s : Symbol(s, Decl(templateLiteralTypes1.ts, 147, 13))

// Infer type variables in template literals have string constraint

type S1<T> = T extends `foo${infer U}bar` ? S2<U> : never;
>S1 : Symbol(S1, Decl(templateLiteralTypes1.ts, 155, 21))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 159, 8))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 159, 8))
>U : Symbol(U, Decl(templateLiteralTypes1.ts, 159, 34))
>S2 : Symbol(S2, Decl(templateLiteralTypes1.ts, 159, 58))
>U : Symbol(U, Decl(templateLiteralTypes1.ts, 159, 34))

type S2<S extends string> = S;
>S2 : Symbol(S2, Decl(templateLiteralTypes1.ts, 159, 58))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 160, 8))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 160, 8))

// Check that infer T declarations are validated

type TV1 = `${infer X}`;
>TV1 : Symbol(TV1, Decl(templateLiteralTypes1.ts, 160, 30))
>X : Symbol(X, Decl(templateLiteralTypes1.ts, 164, 19))

// Batched single character inferences for lower recursion depth

type Chars<S extends string> =
>Chars : Symbol(Chars, Decl(templateLiteralTypes1.ts, 164, 24))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 168, 11))

    string extends S ? string[] :
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 168, 11))

    S extends `${infer C0}${infer C1}${infer C2}${infer C3}${infer C4}${infer C5}${infer C6}${infer C7}${infer C8}${infer C9}${infer R}` ? [C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, ...Chars<R>] :
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 168, 11))
>C0 : Symbol(C0, Decl(templateLiteralTypes1.ts, 170, 22))
>C1 : Symbol(C1, Decl(templateLiteralTypes1.ts, 170, 33))
>C2 : Symbol(C2, Decl(templateLiteralTypes1.ts, 170, 44))
>C3 : Symbol(C3, Decl(templateLiteralTypes1.ts, 170, 55))
>C4 : Symbol(C4, Decl(templateLiteralTypes1.ts, 170, 66))
>C5 : Symbol(C5, Decl(templateLiteralTypes1.ts, 170, 77))
>C6 : Symbol(C6, Decl(templateLiteralTypes1.ts, 170, 88))
>C7 : Symbol(C7, Decl(templateLiteralTypes1.ts, 170, 99))
>C8 : Symbol(C8, Decl(templateLiteralTypes1.ts, 170, 110))
>C9 : Symbol(C9, Decl(templateLiteralTypes1.ts, 170, 121))
>R : Symbol(R, Decl(templateLiteralTypes1.ts, 170, 132))
>C0 : Symbol(C0, Decl(templateLiteralTypes1.ts, 170, 22))
>C1 : Symbol(C1, Decl(templateLiteralTypes1.ts, 170, 33))
>C2 : Symbol(C2, Decl(templateLiteralTypes1.ts, 170, 44))
>C3 : Symbol(C3, Decl(templateLiteralTypes1.ts, 170, 55))
>C4 : Symbol(C4, Decl(templateLiteralTypes1.ts, 170, 66))
>C5 : Symbol(C5, Decl(templateLiteralTypes1.ts, 170, 77))
>C6 : Symbol(C6, Decl(templateLiteralTypes1.ts, 170, 88))
>C7 : Symbol(C7, Decl(templateLiteralTypes1.ts, 170, 99))
>C8 : Symbol(C8, Decl(templateLiteralTypes1.ts, 170, 110))
>C9 : Symbol(C9, Decl(templateLiteralTypes1.ts, 170, 121))
>Chars : Symbol(Chars, Decl(templateLiteralTypes1.ts, 164, 24))
>R : Symbol(R, Decl(templateLiteralTypes1.ts, 170, 132))

    S extends `${infer C}${infer R}` ? [C, ...Chars<R>] :
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 168, 11))
>C : Symbol(C, Decl(templateLiteralTypes1.ts, 171, 22))
>R : Symbol(R, Decl(templateLiteralTypes1.ts, 171, 32))
>C : Symbol(C, Decl(templateLiteralTypes1.ts, 171, 22))
>Chars : Symbol(Chars, Decl(templateLiteralTypes1.ts, 164, 24))
>R : Symbol(R, Decl(templateLiteralTypes1.ts, 171, 32))

    S extends '' ? [] :
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 168, 11))

    never;

type L1 = Chars<'FooBarBazThisIsALongerString'>;  // ['F', 'o', 'o', 'B', 'a', 'r', ...]
>L1 : Symbol(L1, Decl(templateLiteralTypes1.ts, 173, 10))
>Chars : Symbol(Chars, Decl(templateLiteralTypes1.ts, 164, 24))

// Infer never when source isn't a literal type that matches the pattern

type Foo<T> = T extends `*${infer S}*` ? S : never;
>Foo : Symbol(Foo, Decl(templateLiteralTypes1.ts, 175, 48))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 179, 9))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 179, 9))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 179, 33))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 179, 33))

type TF1 = Foo<any>;      // never
>TF1 : Symbol(TF1, Decl(templateLiteralTypes1.ts, 179, 51))
>Foo : Symbol(Foo, Decl(templateLiteralTypes1.ts, 175, 48))

type TF2 = Foo<string>;   // never
>TF2 : Symbol(TF2, Decl(templateLiteralTypes1.ts, 181, 20))
>Foo : Symbol(Foo, Decl(templateLiteralTypes1.ts, 175, 48))

type TF3 = Foo<'abc'>;    // never
>TF3 : Symbol(TF3, Decl(templateLiteralTypes1.ts, 182, 23))
>Foo : Symbol(Foo, Decl(templateLiteralTypes1.ts, 175, 48))

type TF4 = Foo<'*abc*'>;  // 'abc'
>TF4 : Symbol(TF4, Decl(templateLiteralTypes1.ts, 183, 22))
>Foo : Symbol(Foo, Decl(templateLiteralTypes1.ts, 175, 48))

// Cross product unions limited to 100,000 constituents

type A = any;
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))

type U1 = {a1:A} | {b1:A} | {c1:A} | {d1:A} | {e1:A} | {f1:A} | {g1:A} | {h1:A} | {i1:A} | {j1:A};
>U1 : Symbol(U1, Decl(templateLiteralTypes1.ts, 188, 13))
>a1 : Symbol(a1, Decl(templateLiteralTypes1.ts, 190, 11))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>b1 : Symbol(b1, Decl(templateLiteralTypes1.ts, 190, 20))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>c1 : Symbol(c1, Decl(templateLiteralTypes1.ts, 190, 29))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>d1 : Symbol(d1, Decl(templateLiteralTypes1.ts, 190, 38))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>e1 : Symbol(e1, Decl(templateLiteralTypes1.ts, 190, 47))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>f1 : Symbol(f1, Decl(templateLiteralTypes1.ts, 190, 56))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>g1 : Symbol(g1, Decl(templateLiteralTypes1.ts, 190, 65))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>h1 : Symbol(h1, Decl(templateLiteralTypes1.ts, 190, 74))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>i1 : Symbol(i1, Decl(templateLiteralTypes1.ts, 190, 83))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>j1 : Symbol(j1, Decl(templateLiteralTypes1.ts, 190, 92))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))

type U2 = {a2:A} | {b2:A} | {c2:A} | {d2:A} | {e2:A} | {f2:A} | {g2:A} | {h2:A} | {i2:A} | {j2:A};
>U2 : Symbol(U2, Decl(templateLiteralTypes1.ts, 190, 98))
>a2 : Symbol(a2, Decl(templateLiteralTypes1.ts, 191, 11))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>b2 : Symbol(b2, Decl(templateLiteralTypes1.ts, 191, 20))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>c2 : Symbol(c2, Decl(templateLiteralTypes1.ts, 191, 29))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>d2 : Symbol(d2, Decl(templateLiteralTypes1.ts, 191, 38))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>e2 : Symbol(e2, Decl(templateLiteralTypes1.ts, 191, 47))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>f2 : Symbol(f2, Decl(templateLiteralTypes1.ts, 191, 56))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>g2 : Symbol(g2, Decl(templateLiteralTypes1.ts, 191, 65))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>h2 : Symbol(h2, Decl(templateLiteralTypes1.ts, 191, 74))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>i2 : Symbol(i2, Decl(templateLiteralTypes1.ts, 191, 83))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>j2 : Symbol(j2, Decl(templateLiteralTypes1.ts, 191, 92))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))

type U3 = {a3:A} | {b3:A} | {c3:A} | {d3:A} | {e3:A} | {f3:A} | {g3:A} | {h3:A} | {i3:A} | {j3:A};
>U3 : Symbol(U3, Decl(templateLiteralTypes1.ts, 191, 98))
>a3 : Symbol(a3, Decl(templateLiteralTypes1.ts, 192, 11))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>b3 : Symbol(b3, Decl(templateLiteralTypes1.ts, 192, 20))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>c3 : Symbol(c3, Decl(templateLiteralTypes1.ts, 192, 29))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>d3 : Symbol(d3, Decl(templateLiteralTypes1.ts, 192, 38))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>e3 : Symbol(e3, Decl(templateLiteralTypes1.ts, 192, 47))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>f3 : Symbol(f3, Decl(templateLiteralTypes1.ts, 192, 56))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>g3 : Symbol(g3, Decl(templateLiteralTypes1.ts, 192, 65))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>h3 : Symbol(h3, Decl(templateLiteralTypes1.ts, 192, 74))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>i3 : Symbol(i3, Decl(templateLiteralTypes1.ts, 192, 83))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>j3 : Symbol(j3, Decl(templateLiteralTypes1.ts, 192, 92))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))

type U4 = {a4:A} | {b4:A} | {c4:A} | {d4:A} | {e4:A} | {f4:A} | {g4:A} | {h4:A} | {i4:A} | {j4:A};
>U4 : Symbol(U4, Decl(templateLiteralTypes1.ts, 192, 98))
>a4 : Symbol(a4, Decl(templateLiteralTypes1.ts, 193, 11))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>b4 : Symbol(b4, Decl(templateLiteralTypes1.ts, 193, 20))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>c4 : Symbol(c4, Decl(templateLiteralTypes1.ts, 193, 29))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>d4 : Symbol(d4, Decl(templateLiteralTypes1.ts, 193, 38))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>e4 : Symbol(e4, Decl(templateLiteralTypes1.ts, 193, 47))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>f4 : Symbol(f4, Decl(templateLiteralTypes1.ts, 193, 56))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>g4 : Symbol(g4, Decl(templateLiteralTypes1.ts, 193, 65))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>h4 : Symbol(h4, Decl(templateLiteralTypes1.ts, 193, 74))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>i4 : Symbol(i4, Decl(templateLiteralTypes1.ts, 193, 83))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>j4 : Symbol(j4, Decl(templateLiteralTypes1.ts, 193, 92))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))

type U5 = {a5:A} | {b5:A} | {c5:A} | {d5:A} | {e5:A} | {f5:A} | {g5:A} | {h5:A} | {i5:A} | {j5:A};
>U5 : Symbol(U5, Decl(templateLiteralTypes1.ts, 193, 98))
>a5 : Symbol(a5, Decl(templateLiteralTypes1.ts, 194, 11))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>b5 : Symbol(b5, Decl(templateLiteralTypes1.ts, 194, 20))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>c5 : Symbol(c5, Decl(templateLiteralTypes1.ts, 194, 29))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>d5 : Symbol(d5, Decl(templateLiteralTypes1.ts, 194, 38))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>e5 : Symbol(e5, Decl(templateLiteralTypes1.ts, 194, 47))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>f5 : Symbol(f5, Decl(templateLiteralTypes1.ts, 194, 56))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>g5 : Symbol(g5, Decl(templateLiteralTypes1.ts, 194, 65))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>h5 : Symbol(h5, Decl(templateLiteralTypes1.ts, 194, 74))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>i5 : Symbol(i5, Decl(templateLiteralTypes1.ts, 194, 83))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))
>j5 : Symbol(j5, Decl(templateLiteralTypes1.ts, 194, 92))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 184, 24))

type U100000 = U1 & U2 & U3 & U4 & U5;  // Error
>U100000 : Symbol(U100000, Decl(templateLiteralTypes1.ts, 194, 98))
>U1 : Symbol(U1, Decl(templateLiteralTypes1.ts, 188, 13))
>U2 : Symbol(U2, Decl(templateLiteralTypes1.ts, 190, 98))
>U3 : Symbol(U3, Decl(templateLiteralTypes1.ts, 191, 98))
>U4 : Symbol(U4, Decl(templateLiteralTypes1.ts, 192, 98))
>U5 : Symbol(U5, Decl(templateLiteralTypes1.ts, 193, 98))

type Digits = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
>Digits : Symbol(Digits, Decl(templateLiteralTypes1.ts, 196, 38))

type D100000 = `${Digits}${Digits}${Digits}${Digits}${Digits}`;  // Error
>D100000 : Symbol(D100000, Decl(templateLiteralTypes1.ts, 198, 52))
>Digits : Symbol(Digits, Decl(templateLiteralTypes1.ts, 196, 38))
>Digits : Symbol(Digits, Decl(templateLiteralTypes1.ts, 196, 38))
>Digits : Symbol(Digits, Decl(templateLiteralTypes1.ts, 196, 38))
>Digits : Symbol(Digits, Decl(templateLiteralTypes1.ts, 196, 38))
>Digits : Symbol(Digits, Decl(templateLiteralTypes1.ts, 196, 38))

type TDigits = [0] | [1] | [2] | [3] | [4] | [5] | [6] | [7] | [8] | [9];
>TDigits : Symbol(TDigits, Decl(templateLiteralTypes1.ts, 200, 63))

type T100000 = [...TDigits, ...TDigits, ...TDigits, ...TDigits, ...TDigits];  // Error
>T100000 : Symbol(T100000, Decl(templateLiteralTypes1.ts, 202, 73))
>TDigits : Symbol(TDigits, Decl(templateLiteralTypes1.ts, 200, 63))
>TDigits : Symbol(TDigits, Decl(templateLiteralTypes1.ts, 200, 63))
>TDigits : Symbol(TDigits, Decl(templateLiteralTypes1.ts, 200, 63))
>TDigits : Symbol(TDigits, Decl(templateLiteralTypes1.ts, 200, 63))
>TDigits : Symbol(TDigits, Decl(templateLiteralTypes1.ts, 200, 63))

// Repro from #40863

type IsNegative<T extends number> = `${T}` extends `-${string}` ? true : false;
>IsNegative : Symbol(IsNegative, Decl(templateLiteralTypes1.ts, 204, 76))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 208, 16))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 208, 16))

type AA<T extends number, Q extends number> =
>AA : Symbol(AA, Decl(templateLiteralTypes1.ts, 208, 79))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 210, 8))
>Q : Symbol(Q, Decl(templateLiteralTypes1.ts, 210, 25))

    [true, true] extends [IsNegative<T>, IsNegative<Q>] ? 'Every thing is ok!' : ['strange', IsNegative<T>, IsNegative<Q>];
>IsNegative : Symbol(IsNegative, Decl(templateLiteralTypes1.ts, 204, 76))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 210, 8))
>IsNegative : Symbol(IsNegative, Decl(templateLiteralTypes1.ts, 204, 76))
>Q : Symbol(Q, Decl(templateLiteralTypes1.ts, 210, 25))
>IsNegative : Symbol(IsNegative, Decl(templateLiteralTypes1.ts, 204, 76))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 210, 8))
>IsNegative : Symbol(IsNegative, Decl(templateLiteralTypes1.ts, 204, 76))
>Q : Symbol(Q, Decl(templateLiteralTypes1.ts, 210, 25))

type BB = AA<-2, -2>;
>BB : Symbol(BB, Decl(templateLiteralTypes1.ts, 211, 123))
>AA : Symbol(AA, Decl(templateLiteralTypes1.ts, 208, 79))

// Repro from #40970

type PathKeys<T> =
>PathKeys : Symbol(PathKeys, Decl(templateLiteralTypes1.ts, 213, 21))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 217, 14))

    unknown extends T ? never :
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 217, 14))

    T extends readonly any[] ? Extract<keyof T, `${number}`> | SubKeys<T, Extract<keyof T, `${number}`>> :
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 217, 14))
>Extract : Symbol(Extract, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 217, 14))
>SubKeys : Symbol(SubKeys, Decl(templateLiteralTypes1.ts, 221, 10))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 217, 14))
>Extract : Symbol(Extract, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 217, 14))

    T extends object ? Extract<keyof T, string> | SubKeys<T, Extract<keyof T, string>> :
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 217, 14))
>Extract : Symbol(Extract, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 217, 14))
>SubKeys : Symbol(SubKeys, Decl(templateLiteralTypes1.ts, 221, 10))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 217, 14))
>Extract : Symbol(Extract, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 217, 14))

    never;

type SubKeys<T, K extends string> = K extends keyof T ? `${K}.${PathKeys<T[K]>}` : never;
>SubKeys : Symbol(SubKeys, Decl(templateLiteralTypes1.ts, 221, 10))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 223, 13))
>K : Symbol(K, Decl(templateLiteralTypes1.ts, 223, 15))
>K : Symbol(K, Decl(templateLiteralTypes1.ts, 223, 15))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 223, 13))
>K : Symbol(K, Decl(templateLiteralTypes1.ts, 223, 15))
>PathKeys : Symbol(PathKeys, Decl(templateLiteralTypes1.ts, 213, 21))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 223, 13))
>K : Symbol(K, Decl(templateLiteralTypes1.ts, 223, 15))

declare function getProp2<T, P extends PathKeys<T>>(obj: T, path: P): PropType<T, P>;
>getProp2 : Symbol(getProp2, Decl(templateLiteralTypes1.ts, 223, 89))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 225, 26))
>P : Symbol(P, Decl(templateLiteralTypes1.ts, 225, 28))
>PathKeys : Symbol(PathKeys, Decl(templateLiteralTypes1.ts, 213, 21))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 225, 26))
>obj : Symbol(obj, Decl(templateLiteralTypes1.ts, 225, 52))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 225, 26))
>path : Symbol(path, Decl(templateLiteralTypes1.ts, 225, 59))
>P : Symbol(P, Decl(templateLiteralTypes1.ts, 225, 28))
>PropType : Symbol(PropType, Decl(templateLiteralTypes1.ts, 138, 69))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 225, 26))
>P : Symbol(P, Decl(templateLiteralTypes1.ts, 225, 28))

const obj2 = {
>obj2 : Symbol(obj2, Decl(templateLiteralTypes1.ts, 227, 5))

    name: 'John',
>name : Symbol(name, Decl(templateLiteralTypes1.ts, 227, 14))

    age: 42,
>age : Symbol(age, Decl(templateLiteralTypes1.ts, 228, 17))

    cars: [
>cars : Symbol(cars, Decl(templateLiteralTypes1.ts, 229, 12))

        { make: 'Ford', age: 10 },
>make : Symbol(make, Decl(templateLiteralTypes1.ts, 231, 9))
>age : Symbol(age, Decl(templateLiteralTypes1.ts, 231, 23))

        { make: 'Trabant', age: 35 }
>make : Symbol(make, Decl(templateLiteralTypes1.ts, 232, 9))
>age : Symbol(age, Decl(templateLiteralTypes1.ts, 232, 26))

    ]
} as const;
>const : Symbol(const)

let make = getProp2(obj2, 'cars.1.make');  // 'Trabant'
>make : Symbol(make, Decl(templateLiteralTypes1.ts, 236, 3))
>getProp2 : Symbol(getProp2, Decl(templateLiteralTypes1.ts, 223, 89))
>obj2 : Symbol(obj2, Decl(templateLiteralTypes1.ts, 227, 5))

// Repro from #46480

export type Spacing =
>Spacing : Symbol(Spacing, Decl(templateLiteralTypes1.ts, 236, 41))

    | `0`
    | `${number}px`
    | `${number}rem`
    | `s${1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20}`;

const spacing: Spacing = "s12"
>spacing : Symbol(spacing, Decl(templateLiteralTypes1.ts, 246, 5))
>Spacing : Symbol(Spacing, Decl(templateLiteralTypes1.ts, 236, 41))

export type SpacingShorthand =
>SpacingShorthand : Symbol(SpacingShorthand, Decl(templateLiteralTypes1.ts, 246, 30))

    | `${Spacing} ${Spacing}`
>Spacing : Symbol(Spacing, Decl(templateLiteralTypes1.ts, 236, 41))
>Spacing : Symbol(Spacing, Decl(templateLiteralTypes1.ts, 236, 41))

    | `${Spacing} ${Spacing} ${Spacing}`
>Spacing : Symbol(Spacing, Decl(templateLiteralTypes1.ts, 236, 41))
>Spacing : Symbol(Spacing, Decl(templateLiteralTypes1.ts, 236, 41))
>Spacing : Symbol(Spacing, Decl(templateLiteralTypes1.ts, 236, 41))

    | `${Spacing} ${Spacing} ${Spacing} ${Spacing}`;
>Spacing : Symbol(Spacing, Decl(templateLiteralTypes1.ts, 236, 41))
>Spacing : Symbol(Spacing, Decl(templateLiteralTypes1.ts, 236, 41))
>Spacing : Symbol(Spacing, Decl(templateLiteralTypes1.ts, 236, 41))
>Spacing : Symbol(Spacing, Decl(templateLiteralTypes1.ts, 236, 41))

const test1: SpacingShorthand = "0 0 0";
>test1 : Symbol(test1, Decl(templateLiteralTypes1.ts, 253, 5))
>SpacingShorthand : Symbol(SpacingShorthand, Decl(templateLiteralTypes1.ts, 246, 30))

